=head1 Pegex Syntax

Pegex has a fairly simple set of syntax constructs. This document details them
all.

A grammar file/text is split up into two parts:

=head2 Meta Statements

Meta statements are similar to the percent-prefixed declarations found in
yacc, bison, flex, and other parsers:

    # This is the Pegex grammar for Pegex grammars!
    %grammar pegex
    %version 0.1.0

A rule definition will end the meta section.

=head2 Rules

Most of a Pegex grammar is just a set of named rules.  They look like this:

    rule_name_1: <rule>* <body> /1/
    rule_name_2: /rule body 2/

A rule is a name, followed by a ':', followed by a rule body.  It can optionally
end with a semicolon, if you want to put more than one on a line.

=head3 Basic Tokens

Pegex only has 3 kinds of basic tokens:

=over

=item Rule Reference

A rule reference is the name of a rule inside angle brackets.  The brackets
are optional (in most cases; see below).

    <sub_rule_name>
    sub_rule_name

It can have a number of prefix modifiers:

    =<rule>  # Zero-width positive assertion (look-ahead)
    !<rule>  # Zero-width negative assertion (look-ahead)
    .<rule>  # Skip (ie: parse but don't capture a subpattern)
    -<rule>  # Pass (never wrap)
    +<rule>  # Always wrap

(The latter two options and wrapping are discussed L<below|/Return_Values>.)

As well as suffixed quantifiers (similar to REs):

    <rule>?    # optional
    <rule>*    # 0 or more times
    <rule>+    # 1 or more times
    <rule>8    # exactly 8 times
    <rule>2+   # 2 or more times
    <rule>2-3  # 2 or 3 times
    <rule>1-6  # 1 to 6 times

Note that you must use angle brackets if you are using a numbered modifier:

    rule8    # WRONG!  This would match rule "rule8".
    rule2+   # WRONG!  This would match rule "rule2", 1 or more times.
    rule2-3  # This -might- work, but it's certainly unreadable and risky.

Pre-defined "L<Atoms|Pegex::Grammar::Atoms>" exist to enchance readability
and allow for characters that normally cannot be used (like slash or hash):

    <TILDE>   # ~
    <SLASH>   # /
    <HASH>    # # (literal)
    <QMARK>   # ? (literal)
    <STAR>    # * (literal)
    <LPAREN>  # ( (literal)
    <RPAREN>  # ) (literal)
    <WORD>    # \w
    <WS>      # \s
    <ws>      # <WS>*

The full list can be found in the L<Atoms source code|https://metacpan.org/source/Pegex::Grammar::Atoms>.

=item Regular Expression

A regular expression is a string inside forward slashes.

    /regular expression/

The RE syntax mostly follows Perl, with the following exceptions:

    # Any rules in angle brackets are referenced in the RE
    / ( <rule1> | non_rule ) /  # "non_rule" is interpreted literally

    # The syntax implies a /x modifier, so whitespace is ignored.
    / ( <rule1> | <rule2> ) /

    # Whitespace is declared with tildes.
    / ~ <rule3> ~~ /  # ~ = <ws1>, ~~ = <ws2>, etc.

    # Any (?XX ) syntax can have the question mark removed
    / (: <this> | <that> ) /  # just like (?: ) syntax

=item Error Message

An error message is a string inside backticks.

    `error message`

The error message looks like this:

    Error parsing Pegex document:
      msg: $msg
      line: $line
      column: $column
      context: "$context"
      position: $position

The Parser's C<throw_on_error> boolean determines if it's actually
going to C<croak>, or merely stuff the error into C<$@>.  (Default
is yes.)

=back

Rule tokens can be arranged in various ways:

    ~                       # whitespace tildes can be used anywhere
    <token>                 # just a single token
    <token1> <token2>       # both tokens must exist (AND group)
    <token1> | <token2>     # either or (ANY group)
    ( <token> | ~~ )*       # use parens to group up tokens and apply quantifiers
    .( <token> | ~~ )*      # Skip (just like the rule modifier)

    <token>+ %  <DOT>       # one or more tokens are separated by <DOT>
    <token>+ %% <DOT>       # with %%, a trailing <DOT> is okay

    a+ %  b                 # same as: a (b a)*
    a+ %% b                 # same as: a (b a)* b?

    # This is perfectly legal
    rule_name_1:
        / ( <token1>? ) <DOT> ~ /
        rule_name_2
        / ~ <DOT> ( <token2>? ) /
        ( =<token3> | <token4>1-6 )2

C<Any> pipes take precedence over everything else, similar to other parsers:

    # (these are the same)
    a b c    | d %% e
    (a b c ) | (d %% e)

=head1 Return Values

All return values are based on the capture groups (C<$1/$2/$3/etc.> type
variables) of parsed RE statements.  With a basic parser (not invoked via
C<pegex()>), the return value of parsed items are going to be:

    [ $1 ]              # single capture group
    [ [ @+[1..$#+] ] ]  # multiple capture groups

However, you can also turn on "wrapping" with the C<wrap> (boolean) attribute
within the parser.  This will wrap all match values in a hash with the rule
name, like so:

    [ { rule_A => $match } ]
    [ { rule_B => [ @matches ] } ]

Note that this behavior can be "hard set" with the C<+/-> rule modifiers:

    -<rule>  # Never wrap  (even if wrap is set)
    +<rule>  # Always wrap (even if wrap is off)

Any C<got_*> Receiver subs will override even these settings, though, choosing
to pass the match as-is.  In this case, the C<got_*> sub return value dictates
what ultimately gets put into the tree object:

    +rule_A   # in this case, the + is useless here

    sub got_rule_A {
       my ($self, $matches_arrayref) = @_;
       return { foobar => $matches_arrayref };
       # will be received as [ { foobar => [ @matches ] } ]
    }
